import json
import os
import time
import requests
import logging
import re
from django.utils.timezone import now
from attack_surface.models import PortDescription, TechnologyDescription, VulnerabilityDescription

logger = logging.getLogger(__name__)

GEMINI_MODELS = [
    "models/gemini-2.5-flash",
    "models/gemini-2.5-pro",
    "models/gemini-flash-latest"
]

def fetch_vulnerability_description(vulnerability, wapiti_info=None, max_length=300):
    """Fetch a vulnerability description with Gemini API + fallback + caching."""

    logger.debug(f"Fetching description for vulnerability: {vulnerability}, wapiti_info: {wapiti_info}")

    try:
       
        vuln_record = VulnerabilityDescription.objects.filter(vulnerability=vulnerability).first()
        current_time = now()

        if vuln_record and (current_time - vuln_record.updated_at).days < 365:
            print(f"[+] Vulnerability description fetch completed for {vulnerability}: Cached")
            return {
                "status": "success",
                "data": vuln_record.description,
                "message": f"Cached description retrieved for {vulnerability}"
            }

        GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
        if not GEMINI_API_KEY:
            print(f"[+] Vulnerability description fetch failed for {vulnerability}: No API key")
            return {"status": "error", "data": {}, "message": "Gemini API key not set"}

     
        if wapiti_info:
            prompt = f"""Return a JSON object with 'vulnerability' and 'description'.
Provide a SINGLE-LINE advanced technical description for: {vulnerability}
Issue details: {wapiti_info}
Max length {max_length} characters.
Avoid generic phrases like 'is a vulnerability'."""
        else:
            prompt = f"""Return a JSON object with 'vulnerability' and 'description'.
Provide a SINGLE-LINE advanced technical description for: {vulnerability}
Max length {max_length} characters.
Avoid generic phrases like 'is a vulnerability'."""

        payload = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {
                "maxOutputTokens": max(50, max_length // 3),
                "temperature": 0.7
            }
        }

  
        for model in GEMINI_MODELS:
            url = f"https://generativelanguage.googleapis.com/v1beta/{model}:generateContent?key={GEMINI_API_KEY}"
            max_retries = 3

            for attempt in range(max_retries):
                print(f"[+] Attempting Gemini API call ({model}) for {vulnerability} - Attempt {attempt + 1}/{max_retries}")

                try:
                    response = requests.post(url, json=payload, timeout=10)

                    # Retry on rate-limit
                    if response.status_code == 429:
                        if attempt < max_retries - 1:
                            print(f"[+] Rate limit hit, retrying...")
                            time.sleep(2 ** attempt)
                            continue

                    if response.status_code != 200:
                        continue

                    data = response.json()

                 
                    try:
                        result_text = (
                            data["candidates"][0]["content"]["parts"][0].get("text", "").strip()
                        )
                    except:
                        result_text = ""

                    if not result_text:
                        continue

                    # Remove markdown fences
                    if result_text.startswith("```"):
                        result_text = result_text.strip("`").replace("json", "").strip()

                    # Try JSON load
                    try:
                        result_json = json.loads(result_text)
                        description = result_json.get("description", "").strip()

                        if not description:
                            raise ValueError("Missing description")

                        description = re.sub(r"\s+", " ", description)[:max_length]

                        normalized_json = {
                            "vulnerability": vulnerability,
                            "description": description
                        }

                        # Save to DB
                        VulnerabilityDescription.objects.update_or_create(
                            vulnerability=vulnerability,
                            defaults={
                                "description": normalized_json,
                                "created_at": now(),
                                "updated_at": now()
                            }
                        )

                        return {
                            "status": "success",
                            "data": normalized_json,
                            "message": f"Description fetched using {model}"
                        }

                    except Exception:
                        continue  # Try next model

                except Exception as e:
                    if attempt < max_retries - 1:
                        time.sleep(2 ** attempt)
                        continue

            # try next model
            continue

      
        return {
            "status": "partial",
            "data": {
                "vulnerability": vulnerability,
                "description": f"{vulnerability}: Limited data; core impact unavailable."
            },
            "message": "All Gemini model attempts failed."
        }

    except Exception as e:
        print(f"[+] Vulnerability description fetch failed for {vulnerability}: {str(e)}")
        return {"status": "error", "data": {}, "message": str(e)}

def fetch_port_description(port, max_length=300):
    """100% WORKING port description — mirrors working vulnerability function (2025)"""
    print(f"[+] Fetching port description for port {port}")
    logger.debug(f"Fetching description for port: {port}")

    try:
        port_str = str(port).strip()
        record = PortDescription.objects.filter(port=port_str).first()
        if record and (now() - record.updated_at).days < 365:
            print(f"[+] Port description cached for {port}")
            return {"status": "success", "data": record.description, "message": "cached"}

        api_key = os.getenv("GEMINI_API_KEY")
        if not api_key:
            return {"status": "error", "message": "No API key"}

        # THIS IS THE ONLY MODEL THAT WORKS RELIABLY IN 2025
        model = "gemini-1.5-flash"
        url = f"https://generativelanguage.googleapis.com/v1/models/{model}:generateContent?key={api_key}"

        prompt = f'''Return ONLY this exact JSON (no extra text, no markdown):
{{
  "port": "{port_str}",
  "description": "One advanced technical sentence: primary service and protocol on TCP/UDP port {port_str}"
}}'''

        payload = {
            "contents": [{"role": "user", "parts": [{"text": prompt}]}],
            "generationConfig": {
                "temperature": 0.2,
                "maxOutputTokens": 150,
                "response_mime_type": "application/json"  # THIS IS THE KEY
            }
        }

        for attempt in range(3):
            print(f"[+] Trying gemini-1.5-flash for port {port_str} - attempt {attempt+1}/3")
            try:
                r = requests.post(url, json=payload, timeout=20)
                if r.status_code == 429:
                    time.sleep(3)
                    continue
                if r.status_code != 200:
                    continue

                data = r.json()
                text = data.get("candidates", [{}])[0] \
                           .get("content", {}) \
                           .get("parts", [{}])[0] \
                           .get("text", "").strip()

                if not text:
                    continue

                # Clean any remaining markdown
                text = re.sub(r"```json|```", "", text, flags=re.I).strip()

                try:
                    result = json.loads(text)
                    desc = result.get("description", "").strip()
                    if not desc:
                        continue
                except:
                    # Fallback: extract JSON from messy output
                    match = re.search(r'\{.*"description"\s*:\s*"([^"]+)"', text)
                    if match:
                        desc = match.group(1)
                    else:
                        continue

                desc = re.sub(r"\s+", " ", desc)[:max_length]
                normalized = {"port": port_str, "description": desc}

                PortDescription.objects.update_or_create(
                    port=port_str,
                    defaults={"description": normalized, "updated_at": now()}
                )

                print(f"[+] Success: {desc}")
                return {"status": "success", "data": normalized, "message": "gemini-1.5-flash"}

            except Exception as e:
                if attempt == 2:
                    logger.error(f"Port {port_str} failed after 3 attempts: {e}")

        # Final fallback
        fallback = {"port": port_str, "description": f"Port {port_str} - service unknown"}
        PortDescription.objects.update_or_create(
            port=port_str,
            defaults={"description": fallback, "updated_at": now()}
        )
        return {"status": "partial", "data": fallback}

    except Exception as e:
        logger.error(f"Critical error in fetch_port_description: {e}")
        return {"status": "error", "message": str(e)}

def fetch_technology_description(technology, max_length=200):
    """Fetch a single-line advanced technical description from database or Gemini API.
       Mirrors the approach used in fetch_vulnerability_description, and avoids saving
       API-wrapper JSON as the description (extracts nested text instead).
    """
    print(f"[+] Fetching technology description for {technology}")
    logger.debug(f"Fetching description for technology: {technology}")

    def _find_text_in_obj(obj):
        """Recursively search for a 'text' value in a nested JSON-like object."""
        if isinstance(obj, dict):
            # direct 'text' key
            if "text" in obj and isinstance(obj["text"], str) and obj["text"].strip():
                return obj["text"].strip()
            # search all values
            for v in obj.values():
                found = _find_text_in_obj(v)
                if found:
                    return found
        elif isinstance(obj, list):
            for item in obj:
                found = _find_text_in_obj(item)
                if found:
                    return found
        return None

    try:
        tech_record = TechnologyDescription.objects.filter(technology=technology).first()
        current_time = now()

        # Use cached if updated within a year
        if tech_record and (current_time - tech_record.updated_at).days < 365:
            logger.debug(f"Using cached description for {technology}")
            print(f"[+] Technology description fetch completed for {technology}: Cached")
            return {
                "status": "success",
                "data": tech_record.description,
                "message": f"Cached description retrieved for {technology}"
            }

        GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
        if not GEMINI_API_KEY:
            logger.error(f"No Gemini API key set for technology {technology}")
            print(f"[+] Technology description fetch failed for {technology}: No API key")
            return {
                "status": "error",
                "data": {},
                "message": "Gemini API key not set"
            }

        # Build prompt
        prompt = (
            f"Return a JSON object with keys 'technology' and 'description'. "
            f"Provide a SINGLE-LINE advanced technical description for: {technology}. "
            f"Max length {max_length} characters. Avoid generic phrases like 'is a technology'. "
            f"Return only valid JSON."
        )

        payload = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {
                "maxOutputTokens": max(50, max_length // 3),
                "temperature": 0.3
            }
        }

        # Try each model with retries similar to vulnerability function
        for model in GEMINI_MODELS:
            url = f"https://generativelanguage.googleapis.com/v1beta/{model}:generateContent?key={GEMINI_API_KEY}"
            max_retries = 3

            for attempt in range(max_retries):
                print(f"[+] Attempting Gemini API call ({model}) for {technology} - Attempt {attempt + 1}/{max_retries}")

                try:
                    response = requests.post(url, json=payload, timeout=12)

                    # Rate limit handling
                    if response.status_code == 429:
                        if attempt < max_retries - 1:
                            print(f"[+] Rate limit hit for {technology}, retrying...")
                            time.sleep(2 ** attempt)
                            continue

                    if response.status_code != 200:
                        logger.debug(f"Non-200 from Gemini for {technology} (model={model}): {response.status_code}")
                        continue

                    # Try JSON decode of top-level body; if fails, we'll use response.text
                    body_json = None
                    try:
                        body_json = response.json()
                    except Exception:
                        body_json = None

                    # Attempt to extract nested 'text' from an API-wrapper JSON if present
                    result_text = None
                    if isinstance(body_json, dict):
                        # Search for a nested text field inside the wrapper (safe)
                        found_text = _find_text_in_obj(body_json)
                        if found_text:
                            result_text = found_text
                        else:
                            # If wrapper contains obvious API wrapper keys like 'candidates' or 'usageMetadata',
                            # avoid storing the wrapper itself. Use response.text as fallback only if it's not wrapper-like.
                            wrapper_keys = {"candidates", "usageMetadata", "promptTokenCount", "totalTokenCount"}
                            if any(k in body_json for k in wrapper_keys):
                                # we couldn't find nested 'text', treat this attempt as failed and continue
                                logger.debug(f"Detected API-wrapper JSON for {technology} but no nested 'text' found; skipping.")
                                result_text = None
                            else:
                                # The body_json isn't a wrapper — try to convert it into a string candidate
                                # e.g., the model might've returned a direct JSON object { "technology": "...", "description": "..." }
                                try:
                                    # If body_json looks like the desired payload, try to extract description key
                                    if isinstance(body_json.get("description", None), str):
                                        result_text = body_json.get("description").strip()
                                    elif isinstance(body_json.get("technical_description", None), str):
                                        result_text = body_json.get("technical_description").strip()
                                    else:
                                        # fallback: stringify body_json (but only if it looks like the right shape)
                                        result_text = None
                                except Exception:
                                    result_text = None

                    # If we didn't get a result_text from nested JSON, fallback to plain response.text
                    if not result_text:
                        raw_text = (response.text or "").strip()
                        # If raw_text starts with '{' and contains wrapper keys, treat as wrapper and skip
                        if raw_text.startswith("{") and ("\"candidates\"" in raw_text or "\"usageMetadata\"" in raw_text or "\"promptTokenCount\"" in raw_text):
                            logger.debug(f"Raw response looks like API wrapper for {technology}; skipping plain-text fallback.")
                            result_text = None
                        else:
                            result_text = raw_text

                    if not result_text:
                        # nothing usable from this attempt; go to next attempt/model
                        continue

                    # At this point result_text should be the candidate description (or JSON string like {"description": "..."}).
                    result_text = result_text.strip()

                    # Remove markdown fences
                    if result_text.startswith("```json") and result_text.endswith("```"):
                        result_text = result_text[7:-3].strip()
                    elif result_text.startswith("```") and result_text.endswith("```"):
                        result_text = result_text[3:-3].strip()

                    # Try to parse JSON if it looks like JSON
                    parsed = None
                    if result_text.startswith("{"):
                        try:
                            parsed = json.loads(result_text)
                        except Exception:
                            # attempt to find a JSON substring
                            m = re.search(r"\{[\s\S]*\}", result_text)
                            if m:
                                try:
                                    parsed = json.loads(m.group(0))
                                except Exception:
                                    parsed = None

                    # If parsed JSON and contains description, use it
                    if isinstance(parsed, dict) and parsed.get("description"):
                        desc = re.sub(r"\s+", " ", str(parsed.get("description"))).strip()[:max_length]
                        tech_name = parsed.get("technology", parsed.get("technology_name", technology))
                        normalized = {"technology": tech_name, "description": desc}

                        TechnologyDescription.objects.update_or_create(
                            technology=technology,
                            defaults={
                                "description": normalized,
                                "created_at": now(),
                                "updated_at": now()
                            }
                        )

                        print(f"[+] Technology description fetch completed for {technology}")
                        return {
                            "status": "success",
                            "data": normalized,
                            "message": f"Description fetched using {model}"
                        }

                    # If result_text is plain text (not wrapper-like), accept it
                    cleaned_text = re.sub(r"\s+", " ", result_text).strip()
                    if cleaned_text and not (cleaned_text.startswith("{") and ("\"candidates\"" in cleaned_text or "\"usageMetadata\"" in cleaned_text)):
                        # If the text looks like "technology: description", try to split
                        description = cleaned_text[:max_length]
                        if ":" in description and description.split(":", 1)[0].strip().lower().startswith(technology.lower()):
                            parts = description.split(":", 1)
                            tech_name = parts[0].strip()
                            desc = parts[1].strip()
                        else:
                            tech_name = technology
                            desc = description

                        normalized = {"technology": tech_name, "description": re.sub(r"\s+", " ", desc)[:max_length]}

                        TechnologyDescription.objects.update_or_create(
                            technology=technology,
                            defaults={
                                "description": normalized,
                                "created_at": now(),
                                "updated_at": now()
                            }
                        )

                        print(f"[+] Technology description fetch completed for {technology} (plain-text fallback)")
                        return {
                            "status": "success",
                            "data": normalized,
                            "message": f"Description fetched using {model} (plain-text fallback)"
                        }

                    # nothing usable this attempt; try next attempt/model
                    continue

                except Exception as e:
                    logger.warning(f"Gemini call attempt {attempt+1} failed for {technology} (model={model}): {str(e)}")
                    if attempt < max_retries - 1:
                        time.sleep(2 ** attempt)
                        continue
                    logger.error(f"Gemini call failed for {technology} on model {model}: {str(e)}")
                    break  # move to next model

            # try next model
            continue

        # If all models failed, return partial info
        logger.error(f"All Gemini model attempts failed for technology {technology}")
        return {
            "status": "partial",
            "data": {
                "technology": technology,
                "description": f"{technology}: Limited data; core functionality unavailable."
            },
            "message": "All Gemini model attempts failed."
        }

    except Exception as e:
        logger.error(f"Error fetching description for technology {technology}: {str(e)}")
        print(f"[+] Technology description fetch failed for {technology}: {str(e)}")
        return {
            "status": "error",
            "data": {},
            "message": f"Error fetching description: {str(e)}"
        }



import subprocess
def cpe_to_technology_name(cpe):
    """Convert a CPE string to a readable technology name."""
    try:
        if not cpe or not isinstance(cpe, str) or not cpe.startswith("cpe:"):
            logger.debug(f"Invalid CPE format: {cpe}")
            return None
        parts = cpe.split(":")
        if len(parts) < 5:
            logger.debug(f"Incomplete CPE string: {cpe}")
            return None
        vendor = parts[3].replace("_", " ").title()
        product = parts[4].replace("_", " ").title()
        tech_name = f"{vendor} {product}"
        return tech_name
    except Exception as e:
        logger.error(f"Error converting CPE {cpe} to technology name: {str(e)}")
        return None

def get_nrich_data(ip_address):
    """Fetch nrich data for a given IP address, including CPEs, ports, and vulnerabilities."""
    logger.debug(f"Fetching nrich data for IP {ip_address}")
    print(f"[+] Fetching nrich data for IP {ip_address}")
    try:
        result = subprocess.run(
            ["nrich", "-o", "json", "-"],
            input=ip_address,
            text=True,
            capture_output=True,
            check=True
        )
        data = json.loads(result.stdout)
        if not data or not isinstance(data, list) or not data[0]:
            logger.error(f"nrich returned empty or invalid data for IP {ip_address}")
            print(f"[+] nrich data fetch failed for IP {ip_address}: Empty or invalid data")
            return {"status": "error", "error": "Empty or invalid data returned from nrich"}
        
        nrich_data = {
            "status": "success",
            "data": [{
                "ip": data[0].get("ip", ip_address),
                "cpes": data[0].get("cpes", []),
                "ports": data[0].get("ports", []),
                "vulns": data[0].get("vulns", []),
                "cve_vulns": data[0].get("cve_vulns", {}),
                "hostnames": data[0].get("hostnames", []),
                "tags": data[0].get("tags", [])
            }]
        }
        logger.debug(f"nrich data retrieved for IP {ip_address}: {nrich_data}")
        print(f"[+] nrich data fetch completed for IP {ip_address}")
        return nrich_data
    except subprocess.CalledProcessError as e:
        logger.error(f"nrich subprocess error for IP {ip_address}: {str(e)}")
        print(f"[+] nrich data fetch failed for IP {ip_address}: {str(e)}")
        return {"status": "error", "error": f"nrich subprocess error: {str(e)}"}
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON from nrich for IP {ip_address}: {str(e)}")
        print(f"[+] nrich data fetch failed for IP {ip_address}: Invalid JSON")
        return {"status": "error", "error": f"Invalid JSON response: {str(e)}"}
    except Exception as e:
        logger.error(f"Unexpected error fetching nrich data for IP {ip_address}: {str(e)}")
        print(f"[+] nrich data fetch failed for IP {ip_address}: {str(e)}")
        return {"status": "error", "error": f"Unexpected error: {str(e)}"}