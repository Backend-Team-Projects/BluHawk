# attack_surface/vulnerability_description.py
import json
import os
import time
import requests
import logging
import random
import re
import subprocess
from typing import Optional, Tuple, Any

from django.utils.timezone import now
from attack_surface.models import PortDescription, TechnologyDescription, VulnerabilityDescription

logger = logging.getLogger(__name__)

# -------------------------
# Model configuration for Gemini calls (must match GL API path)
# -------------------------
GEMINI_MODELS = [
    "models/gemini-2.5-flash",
    "models/gemini-2.5-pro",
    "models/gemini-flash-latest",
    "models/gemini-2.0-flash",
    # safe preview fallbacks if available
    "models/gemini-2.5-flash-preview-09-2025",
    "models/gemini-2.5-flash-lite",
]

GGL_GL_BASE = "https://generativelanguage.googleapis.com/v1beta/{model}:generateContent"

# Retry/backoff config
MAX_MODEL_RETRIES = 3
BACKOFF_BASE = 0.8
BACKOFF_MULTIPLIER = 2.0
JITTER = 0.3
HTTP_TIMEOUT = 15

# Regex for fenced code blocks
_CODE_FENCE_RE = re.compile(r"^```(?:\w+)?\s*([\s\S]*?)\s*```$", re.MULTILINE)


def _build_url(model_name: str, api_key: str) -> str:
    """Build the full GL API URL for a model and API key."""
    return f"{GGL_GL_BASE.format(model=model_name)}?key={api_key}"


def _clean_gemini_text(text: Any) -> str:
    """Clean text returned by Gemini: remove fences and trim whitespace."""
    if text is None:
        return ""
    try:
        s = str(text).strip()
    except Exception:
        return str(text)
    m = _CODE_FENCE_RE.match(s)
    if m:
        s = m.group(1).strip()
    # strip stray backticks/newlines
    s = s.strip("` \n\r\t")
    return s


def _wrap_if_not_json(text: str) -> str:
    """If text is plain (not JSON), wrap it into a JSON string with 'description' key."""
    if not text or not isinstance(text, str):
        return json.dumps({"description": ""})
    text = text.strip()
    if text.startswith("{"):
        return text
    try:
        return json.dumps({"description": text})
    except Exception:
        return json.dumps({"description": text})


def _parse_gemini_response_json(data: dict) -> Tuple[Optional[str], Optional[str]]:
    """
    Attempt to extract the model's text from common Gemini response shapes.
    Returns (text, error_message). On success error_message is None.
    """
    if not isinstance(data, dict):
        return None, "Non-dict response"

    if "error" in data:
        # bubble up remote error wrapper
        try:
            return None, f"Remote error: {json.dumps(data['error'])}"
        except Exception:
            return None, "Remote error wrapper present"

    # Many possible shapes: 'candidates', 'outputs', or top-level 'text'
    candidates = data.get("candidates") or data.get("outputs") or None
    if candidates and isinstance(candidates, (list, tuple)) and len(candidates) > 0:
        cand = candidates[0]
        # Typical wrapper: cand["content"]["parts"][0]["text"]
        try:
            return cand["content"]["parts"][0]["text"], None
        except Exception:
            pass
        # Alternative: cand["text"]
        if isinstance(cand, dict) and "text" in cand:
            return cand["text"], None
        # Alternative nested attempt
        try:
            nested = cand.get("output", [])[0].get("content", [])[0].get("text")
            if nested:
                return nested, None
        except Exception:
            pass

    # fallback: top-level 'text'
    if "text" in data and isinstance(data["text"], str):
        return data["text"], None

    return None, "Could not locate model text in response"


def call_gemini(prompt: str, max_length: int, gemini_api_key: str) -> Tuple[Optional[str], Optional[str]]:
    """
    Call the Generative Language API with multiple model fallbacks and retries.
    Returns (wrapped_json_string, error_message). If error_message is None, wrapped_json_string contains
    either a JSON string or a JSON wrapper string.
    """
    if not gemini_api_key:
        logger.error("Gemini API key not set")
        return None, "Gemini API key not set"

    # payload follows GL's expected shape
    payload = {
        "contents": [
            {
                "role": "user",
                "parts": [{"text": prompt}]
            }
        ],
        "generationConfig": {
            "maxOutputTokens": max(50, int(max_length // 3)),
            "temperature": 0.3
        }
    }

    tried_models = []
    for model_name in GEMINI_MODELS:
        tried_models.append(model_name)
        url = _build_url(model_name, gemini_api_key)

        for attempt in range(1, MAX_MODEL_RETRIES + 1):
            try:
                resp = requests.post(url, json=payload, headers={"Content-Type": "application/json"}, timeout=HTTP_TIMEOUT)
            except requests.RequestException as e:
                logger.warning("Network error calling Gemini (%s) attempt %d: %s", model_name, attempt, e)
                if attempt < MAX_MODEL_RETRIES:
                    sleep_time = BACKOFF_BASE * (BACKOFF_MULTIPLIER ** (attempt - 1)) + random.random() * JITTER
                    time.sleep(sleep_time)
                    continue
                else:
                    break

            status = resp.status_code
            text_body = resp.text or ""

            # Transient statuses -> retry with backoff
            if status in (429, 503):
                logger.info("Gemini transient status %d for model %s attempt %d", status, model_name, attempt)
                if attempt < MAX_MODEL_RETRIES:
                    sleep_time = BACKOFF_BASE * (BACKOFF_MULTIPLIER ** (attempt - 1)) + random.random() * JITTER
                    time.sleep(sleep_time)
                    continue
                else:
                    break

            # Client errors -> skip model
            if 400 <= status < 500:
                logger.warning("Gemini client error %d for model %s: %s", status, model_name, text_body[:1000])
                break

            if status == 200:
                try:
                    data = resp.json()
                except Exception:
                    # Non-JSON body: try to salvage by cleaning and wrapping as description
                    cleaned = _clean_gemini_text(text_body)
                    wrapped = _wrap_if_not_json(cleaned)
                    return wrapped, None

                text, parse_err = _parse_gemini_response_json(data)
                if parse_err:
                    # Remote error wrapper should be surfaced
                    if parse_err.startswith("Remote error"):
                        return None, parse_err
                    # otherwise proceed to next model
                    logger.debug("Could not extract text for model %s: %s", model_name, parse_err)
                    break

                cleaned = _clean_gemini_text(text)
                wrapped = _wrap_if_not_json(cleaned)
                return wrapped, None

            # unexpected status, try next model
            logger.warning("Unexpected Gemini status %d for model %s", status, model_name)
            break

    return None, f"All Gemini models failed; tried {tried_models}"


# -------------------------
# Public API functions used by AttackSurfaceAPI
# -------------------------
def fetch_vulnerability_description(vulnerability: str, wapiti_info: Optional[str] = None, max_length: int = 300) -> dict:
    """
    Fetch a vulnerability description with caching, Gemini call and fallbacks.
    Returns a dict with keys: status, data, message (matching legacy behavior).
    """
    logger.debug("Fetching vulnerability description for %s", vulnerability)
    try:
        vuln_record = VulnerabilityDescription.objects.filter(vulnerability=vulnerability).first()
        current_time = now()

        # Use cached if updated within 365 days
        if vuln_record and (current_time - vuln_record.updated_at).days < 365:
            logger.debug("Using cached vulnerability description for %s", vulnerability)
            return {"status": "success", "data": vuln_record.description, "message": f"Cached description retrieved for {vulnerability}"}

        GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
        if not GEMINI_API_KEY:
            logger.error("Gemini API key not set for vulnerability description")
            return {"status": "error", "data": {}, "message": "Gemini API key not set"}

        if wapiti_info:
            prompt = (
                f"Return a JSON object with keys 'vulnerability' and 'description'. "
                f"Provide a single-line advanced technical description for: {vulnerability}. "
                f"Issue details: {wapiti_info}. Max length {max_length} characters. "
                f"Return only valid JSON."
            )
        else:
            prompt = (
                f"Return a JSON object with keys 'vulnerability' and 'description'. "
                f"Provide a single-line advanced technical description for: {vulnerability}. "
                f"Max length {max_length} characters. Return only valid JSON."
            )

        result_text, error = call_gemini(prompt, max_length, GEMINI_API_KEY)
        if error:
            logger.warning("call_gemini returned error for vulnerability %s: %s", vulnerability, error)
            # Return partial fallback as legacy did
            return {
                "status": "partial",
                "data": {"vulnerability": vulnerability, "description": f"{vulnerability}: Limited data; core impact unavailable."},
                "message": f"Gemini failure: {error}"
            }

        # attempt to parse resulting JSON
        try:
            result_json = json.loads(result_text)
        except Exception:
            logger.debug("Failed to parse Gemini output as JSON for %s; using fallback", vulnerability)
            result_json = {"vulnerability": vulnerability, "description": f"{vulnerability}: Limited data; core impact unavailable."}

        description = result_json.get("description") or result_json.get("technical_description") or ""
        if not description:
            description = f"{vulnerability}: Limited data; core impact unavailable."

        normalized = {"vulnerability": result_json.get("vulnerability", vulnerability), "description": re.sub(r"\s+", " ", description).strip()[:max_length]}

        # Save to DB (create or update)
        VulnerabilityDescription.objects.update_or_create(
            vulnerability=vulnerability,
            defaults={
                "description": normalized,
                "created_at": now() if not vuln_record else (vuln_record.created_at if hasattr(vuln_record, "created_at") else now()),
                "updated_at": now()
            }
        )

        return {"status": "success", "data": normalized, "message": f"Description fetched for {vulnerability}"}

    except Exception as e:
        logger.exception("Error fetching vulnerability description for %s", vulnerability)
        return {"status": "error", "data": {}, "message": str(e)}


def fetch_port_description(port: int, max_length: int = 50) -> dict:
    """
    Fetch a port description with caching and Gemini fallback.
    Returns {status, data, message}.
    """
    logger.debug("Fetching port description for %s", port)
    try:
        port_str = str(port)
        port_record = PortDescription.objects.filter(port=port_str).first()
        current_time = now()

        if port_record and (current_time - port_record.updated_at).days < 365:
            logger.debug("Using cached port description for %s", port_str)
            return {"status": "success", "data": port_record.description, "message": f"Cached description retrieved for port {port_str}"}

        GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
        if not GEMINI_API_KEY:
            logger.error("Gemini API key not set for port description")
            return {"status": "error", "data": {}, "message": "Gemini API key not set"}

        prompt = (
            f"Return a JSON object with keys 'port' and 'description'. "
            f"Provide a concise single-line advanced technical description for network port {port_str}. "
            f"Max length {max_length} characters. Return only valid JSON."
        )

        result_text, error = call_gemini(prompt, max_length, GEMINI_API_KEY)
        if error:
            logger.warning("call_gemini failed for port %s: %s", port_str, error)
            return {"status": "partial", "data": {"port": port_str, "description": f"Port {port_str}: Limited data; no detailed description."}, "message": f"Gemini failure: {error}"}

        try:
            result_json = json.loads(result_text)
        except Exception:
            logger.debug("Failed to decode Gemini port response as JSON; using fallback for port %s", port_str)
            result_json = {"port": port_str, "description": f"Port {port_str}: Limited data; no detailed description."}

        p_port = str(result_json.get("port", port_str))
        p_desc = result_json.get("description", "").strip()[:max_length] or f"Port {port_str}: Limited data; no detailed description."

        normalized = {"port": p_port, "description": re.sub(r"\s+", " ", p_desc)}

        PortDescription.objects.update_or_create(
            port=port_str,
            defaults={
                "description": normalized,
                "created_at": now() if not port_record else (port_record.created_at if hasattr(port_record, "created_at") else now()),
                "updated_at": now()
            }
        )

        return {"status": "success", "data": normalized, "message": f"Description fetched for port {port_str}"}

    except Exception as e:
        logger.exception("Error fetching port description for %s", port)
        return {"status": "error", "data": {}, "message": str(e)}


def fetch_technology_description(technology: str, max_length: int = 200) -> dict:
    """
    Fetch a single-line advanced technical description for a technology, with caching.
    Returns {status, data, message}.
    """
    logger.debug("Fetching technology description for %s", technology)
    try:
        tech_record = TechnologyDescription.objects.filter(technology=technology).first()
        current_time = now()

        if tech_record and (current_time - tech_record.updated_at).days < 365:
            logger.debug("Using cached technology description for %s", technology)
            return {"status": "success", "data": tech_record.description, "message": f"Cached description retrieved for {technology}"}

        GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
        if not GEMINI_API_KEY:
            logger.error("Gemini API key not set for technology description")
            return {"status": "error", "data": {}, "message": "Gemini API key not set"}

        prompt = (
            f"Return a JSON object with keys 'technology' and 'description'. "
            f"Provide a single-line advanced technical description for: {technology}. "
            f"Max length {max_length} characters. Return only valid JSON."
        )

        result_text, error = call_gemini(prompt, max_length, GEMINI_API_KEY)
        if error:
            logger.warning("call_gemini failed for technology %s: %s", technology, error)
            return {"status": "partial", "data": {"technology": technology, "description": f"{technology}: Limited data; core functionality unavailable."}, "message": f"Gemini failure: {error}"}

        try:
            result_json = json.loads(result_text)
        except Exception:
            logger.debug("Failed to decode Gemini technology response as JSON for %s; using fallback", technology)
            result_json = {"technology": technology, "description": f"{technology}: Limited data; core functionality unavailable."}

        desc = result_json.get("description", "") or f"{technology}: Limited data; core functionality unavailable."
        normalized = {"technology": result_json.get("technology", technology), "description": re.sub(r"\s+", " ", desc).strip()[:max_length]}

        TechnologyDescription.objects.update_or_create(
            technology=technology,
            defaults={
                "description": normalized,
                "created_at": now() if not tech_record else (tech_record.created_at if hasattr(tech_record, "created_at") else now()),
                "updated_at": now()
            }
        )

        return {"status": "success", "data": normalized, "message": f"Description fetched for {technology}"}

    except Exception as e:
        logger.exception("Error fetching technology description for %s", technology)
        return {"status": "error", "data": {}, "message": str(e)}


def cpe_to_technology_name(cpe: str) -> Optional[str]:
    """Convert a CPE string to a readable technology name (vendor + product)."""
    try:
        if not cpe or not isinstance(cpe, str) or not cpe.startswith("cpe:"):
            logger.debug("Invalid CPE format: %s", cpe)
            return None
        parts = cpe.split(":")
        if len(parts) < 5:
            logger.debug("Incomplete CPE string: %s", cpe)
            return None
        vendor = parts[3].replace("_", " ").title()
        product = parts[4].replace("_", " ").title()
        return f"{vendor} {product}"
    except Exception as e:
        logger.exception("Error converting CPE %s to technology name: %s", cpe, e)
        return None


def get_nrich_data(ip_address: str) -> dict:
    """
    Run 'nrich' subprocess to collect CPEs, ports, vulns and return in expected structure.
    Keeps the same return shape as the legacy implementation.
    """
    logger.debug("Fetching nrich data for %s", ip_address)
    try:
        result = subprocess.run(
            ["nrich", "-o", "json", "-"],
            input=ip_address,
            text=True,
            capture_output=True,
            check=True
        )
        data = json.loads(result.stdout)
        if not data or not isinstance(data, list) or not data[0]:
            logger.error("nrich returned invalid data for %s", ip_address)
            return {"status": "error", "error": "Empty or invalid data returned from nrich"}

        nrich_data = {
            "status": "success",
            "data": [{
                "ip": data[0].get("ip", ip_address),
                "cpes": data[0].get("cpes", []),
                "ports": data[0].get("ports", []),
                "vulns": data[0].get("vulns", []),
                "cve_vulns": data[0].get("cve_vulns", {}),
                "hostnames": data[0].get("hostnames", []),
                "tags": data[0].get("tags", [])
            }]
        }
        return nrich_data
    except subprocess.CalledProcessError as e:
        logger.exception("nrich subprocess error for %s", ip_address)
        return {"status": "error", "error": f"nrich subprocess error: {str(e)}"}
    except json.JSONDecodeError as e:
        logger.exception("Invalid JSON from nrich for %s", ip_address)
        return {"status": "error", "error": f"Invalid JSON response: {str(e)}"}
    except Exception as e:
        logger.exception("Unexpected error fetching nrich data for %s", ip_address)
        return {"status": "error", "error": f"Unexpected error: {str(e)}"}
