import json
import os
import time
import requests
import logging
import re
from django.utils.timezone import now
from attack_surface.models import PortDescription, TechnologyDescription, VulnerabilityDescription

# Set up logging
logger = logging.getLogger(__name__)

def fetch_vulnerability_description(vulnerability, wapiti_info=None, max_length=300):
    """Fetch a single-line advanced technical description for a vulnerability from database or Gemini API, incorporating Wapiti scan details."""
    # print(f"[+] Fetching vulnerability description for {vulnerability} with info: {wapiti_info}")
    logger.debug(f"Fetching description for vulnerability: {vulnerability}, wapiti_info: {wapiti_info}")
    try:
        vuln_record = VulnerabilityDescription.objects.filter(vulnerability=vulnerability).first()
        current_time = now()
        if vuln_record and (current_time - vuln_record.updated_at).days < 365:
            logger.debug(f"Using cached description for {vulnerability}")
            print(f"[+] Vulnerability description fetch completed for {vulnerability}: Cached")
            return {
                "status": "success",
                "data": vuln_record.description,
                "message": f"Cached description retrieved for {vulnerability}"
            }

        GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
        if not GEMINI_API_KEY:
            logger.error(f"No Gemini API key set for vulnerability {vulnerability}")
            print(f"[+] Vulnerability description fetch failed for {vulnerability}: No API key")
            return {
                "status": "error",
                "data": {},
                "message": "Gemini API key not set"
            }

        url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={GEMINI_API_KEY}"
        headers = {"Content-Type": "application/json"}
        # Include wapiti_info in the prompt if provided, otherwise use vulnerability name only
        if wapiti_info:
            prompt = """Return a JSON object with 'vulnerability' and 'description' keys, wrapped in ```json\n...\n```.
Provide a single-line, advanced technical description for {vulnerability} with issue "{wapiti_info}", max {max_length} characters,
focusing on its core impact or risk without generic phrases like 'is a vulnerability'.""".format(
                vulnerability=vulnerability, wapiti_info=wapiti_info, max_length=max_length
            )
        else:
            prompt = """Return a JSON object with 'vulnerability' and 'description' keys, wrapped in ```json\n...\n```.
Provide a single-line, advanced technical description for {vulnerability}, max {max_length} characters,
focusing on its core impact or risk without generic phrases like 'is a vulnerability'.""".format(
                vulnerability=vulnerability, max_length=max_length
            )
        payload = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {
                "maxOutputTokens": max(50, max_length // 3),  # Adjusted to reduce truncation
                "temperature": 0.7  # Balance creativity and precision
            }
        }
        max_retries = 3
        for attempt in range(max_retries):
            print(f"[+] Attempting Gemini API call for {vulnerability} (Attempt {attempt + 1}/{max_retries})")
            try:
                response = requests.post(url, headers=headers, json=payload, timeout=10)
                logger.debug(f"Gemini API response for {vulnerability}: status={response.status_code}, text={response.text[:1000]}")
                
                if response.status_code != 200:
                    if response.status_code == 429 and attempt < max_retries - 1:
                        logger.warning(f"Rate limit hit for {vulnerability}, retrying in {2 ** attempt}s")
                        print(f"[+] Gemini API rate limit hit for {vulnerability}, retrying")
                        time.sleep(2 ** attempt)
                        continue
                    logger.error(f"Gemini API returned status {response.status_code} for {vulnerability}: {response.text[:1000]}")
                    print(f"[+] Vulnerability description fetch failed for {vulnerability}: Status {response.status_code}")
                    return {
                        "status": "error",
                        "data": {},
                        "message": f"Gemini API returned status {response.status_code}: {response.text[:1000]}"
                    }
                
                try:
                    data = response.json()
                except json.JSONDecodeError as e:
                    logger.error(f"Non-JSON response for {vulnerability}: {response.text[:1000]}, error: {str(e)}")
                    print(f"[+] Vulnerability description fetch failed for {vulnerability}: Non-JSON response {str(e)}")
                    return {
                        "status": "partial",
                        "data": {
                            "vulnerability": vulnerability,
                            "description": f"{vulnerability}: Limited data; core impact unavailable."
                        },
                        "message": f"Non-JSON API response: {response.text[:1000]}"
                    }
                
                result_text = data.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("text", "")
                logger.debug(f"Raw Gemini API response for {vulnerability}: {result_text[:1000]}")
                
                if not result_text:
                    logger.error(f"Empty response from Gemini API for {vulnerability}")
                    print(f"[+] Vulnerability description fetch failed for {vulnerability}: Empty response")
                    return {
                        "status": "partial",
                        "data": {
                            "vulnerability": vulnerability,
                            "description": f"{vulnerability}: Limited data; core impact unavailable."
                        },
                        "message": f"Empty response from Gemini API"
                    }

                result_text = result_text.strip()
                if result_text.startswith("```json") and result_text.endswith("```"):
                    result_text = result_text[7:-3].strip()
                elif result_text.startswith("```") and result_text.endswith("```"):
                    result_text = result_text[3:-3].strip()
                
                try:
                    result_json = json.loads(result_text)
                    logger.debug(f"Parsed Gemini API JSON for {vulnerability}: {result_json}")
                    description = result_json.get("description", result_json.get("technical_description", ""))
                    if not description:
                        raise ValueError("Missing description in JSON")
                    normalized_json = {
                        "vulnerability": result_json.get("vulnerability", vulnerability),
                        "description": re.sub(r'\s+', ' ', description).strip()[:max_length]  # Ensure single-line
                    }
                    VulnerabilityDescription.objects.update_or_create(
                        vulnerability=vulnerability,
                        defaults={
                            "description": normalized_json,
                            "created_at": now(),
                            "updated_at": now()
                        }
                    )
                    logger.debug(f"Stored Gemini API description for {vulnerability}: {normalized_json}")
                    # print(f"[+] Vulnerability description fetch completed for {vulnerability}")
                    return {
                        "status": "success",
                        "data": normalized_json,
                        "message": f"Description fetched from Gemini API for {vulnerability}"
                    }
                except (json.JSONDecodeError, ValueError) as e:
                    logger.error(f"Invalid JSON or structure for {vulnerability}: {result_text[:1000]}, error: {str(e)}")
                    print(f"[+] Vulnerability description fetch failed for {vulnerability}: Invalid response {str(e)}")
                    
                    json_match = re.match(
                        r'```json\n\s*\{\s*"(vulnerability|vulnerability_name)":\s*"([^"]*)"\s*,\s*"(description|technical_description)":\s*"([^"]*?)(?:"|(?:\n\s*}\s*```|$))',
                        result_text,
                        re.DOTALL
                    )
                    if json_match:
                        logger.debug(f"Regex matched for {vulnerability}: groups={json_match.groups()}")
                        description = re.sub(r'\s+', ' ', json_match.group(4)).strip()[:max_length]
                        normalized_json = {
                            "vulnerability": json_match.group(2),
                            "description": description or f"{vulnerability}: Limited data; core impact unavailable."
                        }
                        VulnerabilityDescription.objects.update_or_create(
                            vulnerability=vulnerability,
                            defaults={
                                "description": normalized_json,
                                "created_at": now(),
                                "updated_at": now()
                            }
                        )
                        logger.debug(f"Stored regex-parsed description for {vulnerability}: {normalized_json}")
                        print(f"[+] Vulnerability description fetch completed for {vulnerability} using regex fallback")
                        return {
                            "status": "success",
                            "data": normalized_json,
                            "message": f"Description fetched from Gemini API for {vulnerability} using regex fallback"
                        }
                    
                    logger.debug(f"Regex parsing failed for {vulnerability}: no match found")
                    return {
                        "status": "partial",
                        "data": {
                            "vulnerability": vulnerability,
                            "description": f"{vulnerability}: Limited data; core impact unavailable."
                        },
                        "message": f"Fallback description used for {vulnerability} due to invalid response: {result_text[:1000]}"
                    }
            except requests.RequestException as e:
                if attempt < max_retries - 1:
                    logger.warning(f"Request failed for {vulnerability}, retrying in {2 ** attempt}s: {str(e)}")
                    print(f"[+] Gemini API request failed for {vulnerability}, retrying")
                    time.sleep(2 ** attempt)
                    continue
                logger.error(f"Gemini API request failed for {vulnerability}: {str(e)}")
                print(f"[+] Vulnerability description fetch failed for {vulnerability}: {str(e)}")
                return {
                    "status": "error",
                    "data": {},
                    "message": f"Gemini API request failed: {str(e)}"
                }
    except Exception as e:
        logger.error(f"Error fetching description for {vulnerability}: {str(e)}")
        print(f"[+] Vulnerability description fetch failed for {vulnerability}: {str(e)}")
        return {
            "status": "error",
            "data": {},
            "message": f"Error fetching description: {str(e)}"
        }
def fetch_port_description(port):

    """Fetch port description from database or Gemini API."""
    print(f"[+] Fetching port description for port {port}")
    logger.debug(f"Fetching description for port: {port}")
    try:
        port_record = PortDescription.objects.filter(port=str(port)).first()
        current_time = now()
        if port_record and (current_time - port_record.updated_at).days < 365:
            logger.debug(f"Using cached description for port {port}")
            print(f"[+] Port description fetch completed for port {port}: Cached")
            return {
                "status": "success",
                "data": port_record.description,
                "message": f"Cached description retrieved for port {port}"
            }

        GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
        if not GEMINI_API_KEY:
            logger.error(f"No Gemini API key set for port {port}")
            print(f"[+] Port description fetch failed for port {port}: No API key")
            return {
                "status": "error",
                "data": {},
                "message": "Gemini API key not set"
            }

        url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={GEMINI_API_KEY}"
        headers = {
            "Content-Type": "application/json"
        }
        prompt = f"""Return a JSON object containing 'port' and 'description' keys. The response must be valid JSON wrapped in ```json\n...\n```. Provide a concise, single-line, advanced technical description for the network port {port}. Do not include any explanations or plain text outside the JSON."""
        payload = {
            "contents": [{
                "parts": [{
                    "text": prompt
                }]
            }],
            "generationConfig": {
                "maxOutputTokens": 200  # Matches vulnerability_description for consistency
            }
        }
        max_retries = 3
        for attempt in range(max_retries):
            print(f"[+] Attempting Gemini API call for port {port} (Attempt {attempt + 1}/{max_retries})")
            try:
                response = requests.post(url, headers=headers, json=payload, timeout=10)
                logger.debug(f"Full Gemini API response for port {port}: status={response.status_code}, headers={response.headers}, text={response.text[:1000]}")
                
                if response.status_code != 200:
                    if response.status_code == 429 and attempt < max_retries - 1:
                        logger.warning(f"Rate limit hit for port {port}, retrying in {2 ** attempt}s")
                        print(f"[+] Gemini API rate limit hit for port {port}, retrying")
                        time.sleep(2 ** attempt)
                        continue
                    logger.error(f"Gemini API returned status {response.status_code} for port {port}: {response.text[:1000]}")
                    print(f"[+] Port description fetch failed for port {port}: Status {response.status_code}")
                    return {
                        "status": "error",
                        "data": {},
                        "message": f"Gemini API returned status {response.status_code}: {response.text[:1000]}"
                    }
                
                # Try to parse the response as JSON first
                try:
                    data = response.json()
                except json.JSONDecodeError as e:
                    logger.error(f"Gemini API response is not valid JSON for port {port}: {response.text[:1000]}, error: {str(e)}")
                    print(f"[+] Port description fetch failed for port {port}: Non-JSON response, {str(e)}")
                    return {
                        "status": "partial",
                        "data": {
                            "port": str(port),
                            "description": f"Port {port} is a network port with no detailed description available from the API."
                        },
                        "message": f"Non-JSON API response: {response.text[:1000]}"
                    }
                
                result_text = data.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("text", "")
                logger.debug(f"Raw Gemini API response text for port {port}: {result_text[:1000]}")
                
                if not result_text:
                    logger.error(f"Empty response text from Gemini API for port {port}")
                    print(f"[+] Port description fetch failed for port {port}: Empty response")
                    return {
                        "status": "partial",
                        "data": {
                            "port": str(port),
                            "description": f"Port {port} is a network port with no detailed description available from the API."
                        },
                        "message": f"Empty response from Gemini API for port {port}"
                    }

                # Strip markdown code block markers
                result_text = result_text.strip()
                if result_text.startswith("```json") and result_text.endswith("```"):
                    result_text = result_text[7:-3].strip()
                elif result_text.startswith("```") and result_text.endswith("```"):
                    result_text = result_text[3:-3].strip()
                
                # Attempt to parse the extracted text as JSON
                try:
                    result_json = json.loads(result_text)
                    logger.debug(f"Parsed Gemini API JSON for port {port}: {result_json}")
                    if "port" in result_json and "description" in result_json:
                        normalized_json = {
                            "port": str(result_json["port"]),
                            "description": result_json["description"]
                        }
                    else:
                        logger.error(f"Invalid key structure in Gemini API response for port {port}: {result_text[:1000]}")
                        print(f"[+] Port description fetch failed for port {port}: Invalid key structure")
                        normalized_json = {
                            "port": str(port),
                            "description": f"Port {port} is a network port with no detailed description available from the API."
                        }
                        return {
                            "status": "partial",
                            "data": normalized_json,
                            "message": f"Fallback description used for port {port} due to invalid key structure: {result_text[:1000]}"
                        }
                    
                    # Store the result in the database
                    PortDescription.objects.update_or_create(
                        port=str(port),
                        defaults={
                            "description": normalized_json,
                            "created_at": now(),
                            "updated_at": now()
                        }
                    )
                    logger.debug(f"Stored Gemini API description for port {port}")
                    print(f"[+] Port description fetch completed for port {port}")
                    return {
                        "status": "success",
                        "data": normalized_json,
                        "message": f"Description fetched from Gemini API for port {port}"
                    }
                except json.JSONDecodeError as e:
                    logger.error(f"Gemini API response text is not valid JSON for port {port}: {result_text[:1000]}, error: {str(e)}")
                    print(f"[+] Port description fetch failed for port {port}: Non-JSON response, {str(e)}")
                    
                    # Fallback: Attempt regex-based parsing for truncated JSON
                    json_match = re.match(
                        r'```json\n\s*\{\s*"port":\s*"([^"]*)"\s*,\s*"description":\s*"([^"]*)"(?:\s*,.*)?\}\s*\n```',
                        result_text,
                        re.DOTALL
                    )
                    if json_match:
                        logger.debug(f"Regex matched for port {port}: groups={json_match.groups()}")
                        normalized_json = {
                            "port": json_match.group(1),
                            "description": json_match.group(2)
                        }
                        PortDescription.objects.update_or_create(
                            port=str(port),
                            defaults={
                                "description": normalized_json,
                                "created_at": now(),
                                "updated_at": now()
                            }
                        )
                        logger.debug(f"Stored regex-parsed description for port {port}: {normalized_json}")
                        print(f"[+] Port description fetch completed for port {port} using regex fallback")
                        return {
                            "status": "success",
                            "data": normalized_json,
                            "message": f"Description fetched from Gemini API for port {port} using regex fallback due to truncation"
                        }
                    
                    logger.debug(f"Regex parsing failed for port {port}: no match found")
                    return {
                        "status": "partial",
                        "data": {
                            "port": str(port),
                            "description": f"Port {port} is a network port with no detailed description available from the API."
                        },
                        "message": f"Fallback description used for port {port} due to non-JSON response: {result_text[:1000]}"
                    }
            except requests.RequestException as e:
                if attempt < max_retries - 1:
                    logger.warning(f"Request failed for port {port}, retrying in {2 ** attempt}s: {str(e)}")
                    print(f"[+] Gemini API request failed for port {port}, retrying")
                    time.sleep(2 ** attempt)
                    continue
                logger.error(f"Gemini API request failed for port {port}: {str(e)}")
                print(f"[+] Port description fetch failed for port {port}: {str(e)}")
                return {
                    "status": "error",
                    "data": {},
                    "message": f"Gemini API request failed: {str(e)}"
                }
    except Exception as e:
        logger.error(f"Error fetching description for port {port}: {str(e)}")
        print(f"[+] Port description fetch failed for port {port}: {str(e)}")
        return {
            "status": "error",
            "data": {},
            "message": f"Error fetching description: {str(e)}"
        }


def fetch_technology_description(technology, max_length=200):
    """Fetch a single-line advanced technical description from database or Gemini API."""
    print(f"[+] Fetching technology description for {technology}")
    logger.debug(f"Fetching description for technology: {technology}")
    try:
        tech_record = TechnologyDescription.objects.filter(technology=technology).first()
        current_time = now()
        if tech_record and (current_time - tech_record.updated_at).days < 365:
            logger.debug(f"Using cached description for {technology}")
            print(f"[+] Technology description fetch completed for {technology}: Cached")
            return {
                "status": "success",
                "data": tech_record.description,
                "message": f"Cached description retrieved for {technology}"
            }

        GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
        if not GEMINI_API_KEY:
            logger.error(f"No Gemini API key set for technology {technology}")
            print(f"[+] Technology description fetch failed for {technology}: No API key")
            return {
                "status": "error",
                "data": {},
                "message": "Gemini API key not set"
            }

        url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={GEMINI_API_KEY}"
        headers = {"Content-Type": "application/json"}
        prompt = """Return a JSON object with 'technology' and 'description' keys, wrapped in ```json\n...\n```.
Provide a single-line, advanced technical description for {technology}, max {max_length} characters,
focusing on its core function or role without generic phrases like 'is a technology'.""".format(
            technology=technology, max_length=max_length
        )
        payload = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {
                "maxOutputTokens": max(50, max_length // 3),  # Increased to reduce truncation
                "temperature": 0.7  # Balance creativity and precision
            }
        }
        max_retries = 3
        for attempt in range(max_retries):
            print(f"[+] Attempting Gemini API call for {technology} (Attempt {attempt + 1}/{max_retries})")
            try:
                response = requests.post(url, headers=headers, json=payload, timeout=15)
                logger.debug(f"Gemini API response for {technology}: status={response.status_code}, text={response.text[:1000]}")
                
                if response.status_code != 200:
                    if response.status_code == 429 and attempt < max_retries - 1:
                        logger.warning(f"Rate limit hit for {technology}, retrying in {2 ** attempt}s")
                        print(f"[+] Gemini API rate limit hit for {technology}, retrying")
                        time.sleep(2 ** attempt)
                        continue
                    logger.error(f"Gemini API returned status {response.status_code} for {technology}: {response.text[:1000]}")
                    print(f"[+] Technology description fetch failed for {technology}: Status {response.status_code}")
                    return {
                        "status": "error",
                        "data": {},
                        "message": f"Gemini API returned status {response.status_code}: {response.text[:1000]}"
                    }
                
                try:
                    data = response.json()
                except json.JSONDecodeError as e:
                    logger.error(f"Non-JSON response for {technology}: {response.text[:1000]}, error: {str(e)}")
                    print(f"[+] Technology description fetch failed for {technology}: Non-JSON response, {str(e)}")
                    return {
                        "status": "partial",
                        "data": {
                            "technology": technology,
                            "description": f"{technology}: Limited data; core functionality unavailable."
                        },
                        "message": f"Non-JSON API response: {response.text[:1000]}"
                    }
                
                result_text = data.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("text", "")
                logger.debug(f"Raw Gemini API response for {technology}: {result_text[:1000]}")
                
                if not result_text:
                    logger.error(f"Empty response from Gemini API for {technology}")
                    print(f"[+] Technology description fetch failed for {technology}: Empty response")
                    return {
                        "status": "partial",
                        "data": {
                            "technology": technology,
                            "description": f"{technology}: Limited data; core functionality unavailable."
                        },
                        "message": f"Empty response from Gemini API"
                    }

                result_text = result_text.strip()
                if result_text.startswith("```json") and result_text.endswith("```"):
                    result_text = result_text[7:-3].strip()
                elif result_text.startswith("```") and result_text.endswith("```"):
                    result_text = result_text[3:-3].strip()
                
                try:
                    result_json = json.loads(result_text)
                    logger.debug(f"Parsed Gemini API JSON for {technology}: {result_json}")
                    description = result_json.get("description", result_json.get("technical_description", ""))
                    if not description:
                        raise ValueError("Missing description in JSON")
                    normalized_json = {
                        "technology": result_json.get("technology", result_json.get("technology_name", technology)),
                        "description": re.sub(r'\s+', ' ', description).strip()[:max_length]  # Ensure single-line
                    }
                    TechnologyDescription.objects.update_or_create(
                        technology=technology,
                        defaults={
                            "description": normalized_json,
                            "created_at": now(),
                            "updated_at": now()
                        }
                    )
                    logger.debug(f"Stored Gemini API description for {technology}: {normalized_json}")
                    print(f"[+] Technology description fetch completed for {technology}")
                    return {
                        "status": "success",
                        "data": normalized_json,
                        "message": f"Description fetched from Gemini API for {technology}"
                    }
                except (json.JSONDecodeError, ValueError) as e:
                    logger.error(f"Invalid JSON or structure for {technology}: {result_text[:1000]}, error: {str(e)}")
                    print(f"[+] Technology description fetch failed for {technology}: Invalid response, {str(e)}")
                    
                    json_match = re.match(
                        r'```json\n\s*\{\s*"(technology|technology_name)":\s*"([^"]*)"\s*,\s*"(description|technical_description)":\s*"([^"]*?)(?:"|(?:\n\s*}\s*```|$))',
                        result_text,
                        re.DOTALL
                    )
                    if json_match:
                        logger.debug(f"Regex matched for {technology}: groups={json_match.groups()}")
                        description = re.sub(r'\s+', ' ', json_match.group(4)).strip()[:max_length]
                        normalized_json = {
                            "technology": json_match.group(2),
                            "description": description or f"{technology}: Limited data; core functionality unavailable."
                        }
                        TechnologyDescription.objects.update_or_create(
                            technology=technology,
                            defaults={
                                "description": normalized_json,
                                "created_at": now(),
                                "updated_at": now()
                            }
                        )
                        logger.debug(f"Stored regex-parsed description for {technology}: {normalized_json}")
                        print(f"[+] Technology description fetch completed for {technology} using regex fallback")
                        return {
                            "status": "success",
                            "data": normalized_json,
                            "message": f"Description fetched from Gemini API for {technology} using regex fallback"
                        }
                    
                    logger.debug(f"Regex parsing failed for {technology}: no match found")
                    return {
                        "status": "partial",
                        "data": {
                            "technology": technology,
                            "description": f"{technology}: Limited data; core functionality unavailable."
                        },
                        "message": f"Fallback description used for {technology} due to invalid response: {result_text[:1000]}"
                    }
            except requests.RequestException as e:
                if attempt < max_retries - 1:
                    logger.warning(f"Request failed for {technology}, retrying in {2 ** attempt}s: {str(e)}")
                    print(f"[+] Gemini API request failed for {technology}, retrying")
                    time.sleep(2 ** attempt)
                    continue
                logger.error(f"Gemini API request failed for {technology}: {str(e)}")
                print(f"[+] Technology description fetch failed for {technology}: {str(e)}")
                return {
                    "status": "error",
                    "data": {},
                    "message": f"Gemini API request failed: {str(e)}"
                }
    except Exception as e:
        logger.error(f"Error fetching description for {technology}: {str(e)}")
        print(f"[+] Technology description fetch failed for {technology}: {str(e)}")
        return {
            "status": "error",
            "data": {},
            "message": f"Error fetching description: {str(e)}"
        }
    
import subprocess
def cpe_to_technology_name(cpe):
    """Convert a CPE string to a readable technology name."""
    try:
        if not cpe or not isinstance(cpe, str) or not cpe.startswith("cpe:"):
            logger.debug(f"Invalid CPE format: {cpe}")
            return None
        parts = cpe.split(":")
        if len(parts) < 5:
            logger.debug(f"Incomplete CPE string: {cpe}")
            return None
        vendor = parts[3].replace("_", " ").title()
        product = parts[4].replace("_", " ").title()
        tech_name = f"{vendor} {product}"
        return tech_name
    except Exception as e:
        logger.error(f"Error converting CPE {cpe} to technology name: {str(e)}")
        return None

def get_nrich_data(ip_address):
    """Fetch nrich data for a given IP address, including CPEs, ports, and vulnerabilities."""
    logger.debug(f"Fetching nrich data for IP {ip_address}")
    print(f"[+] Fetching nrich data for IP {ip_address}")
    try:
        result = subprocess.run(
            ["nrich", "-o", "json", "-"],
            input=ip_address,
            text=True,
            capture_output=True,
            check=True
        )
        data = json.loads(result.stdout)
        if not data or not isinstance(data, list) or not data[0]:
            logger.error(f"nrich returned empty or invalid data for IP {ip_address}")
            print(f"[+] nrich data fetch failed for IP {ip_address}: Empty or invalid data")
            return {"status": "error", "error": "Empty or invalid data returned from nrich"}
        
        nrich_data = {
            "status": "success",
            "data": [{
                "ip": data[0].get("ip", ip_address),
                "cpes": data[0].get("cpes", []),
                "ports": data[0].get("ports", []),
                "vulns": data[0].get("vulns", []),
                "cve_vulns": data[0].get("cve_vulns", {}),
                "hostnames": data[0].get("hostnames", []),
                "tags": data[0].get("tags", [])
            }]
        }
        logger.debug(f"nrich data retrieved for IP {ip_address}: {nrich_data}")
        print(f"[+] nrich data fetch completed for IP {ip_address}")
        return nrich_data
    except subprocess.CalledProcessError as e:
        logger.error(f"nrich subprocess error for IP {ip_address}: {str(e)}")
        print(f"[+] nrich data fetch failed for IP {ip_address}: {str(e)}")
        return {"status": "error", "error": f"nrich subprocess error: {str(e)}"}
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON from nrich for IP {ip_address}: {str(e)}")
        print(f"[+] nrich data fetch failed for IP {ip_address}: Invalid JSON")
        return {"status": "error", "error": f"Invalid JSON response: {str(e)}"}
    except Exception as e:
        logger.error(f"Unexpected error fetching nrich data for IP {ip_address}: {str(e)}")
        print(f"[+] nrich data fetch failed for IP {ip_address}: {str(e)}")
        return {"status": "error", "error": f"Unexpected error: {str(e)}"}